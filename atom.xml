<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jqcc</title>
  <icon>https://www.gravatar.com/avatar/1236dd6b558ef825878a2742fb65e7c2</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-16T08:25:46.991Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>jqcc</name>
    <email>897238475@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>123</title>
    <link href="http://yoursite.com/2018/11/16/123/"/>
    <id>http://yoursite.com/2018/11/16/123/</id>
    <published>2018-11-16T08:24:40.000Z</published>
    <updated>2018-11-16T08:25:46.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="headline"><a href="#headline" class="headerlink" title="headline"></a>headline</h1><h2 id="title2"><a href="#title2" class="headerlink" title="title2"></a>title2</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;headline&quot;&gt;&lt;a href=&quot;#headline&quot; class=&quot;headerlink&quot; title=&quot;headline&quot;&gt;&lt;/a&gt;headline&lt;/h1&gt;&lt;h2 id=&quot;title2&quot;&gt;&lt;a href=&quot;#title2&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nndl1使用梯度下降算法进行学习</title>
    <link href="http://yoursite.com/2018/11/03/nndl1%E4%BD%BF%E7%94%A8%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/11/03/nndl1使用梯度下降算法进行学习/</id>
    <published>2018-11-03T07:55:12.000Z</published>
    <updated>2018-11-03T08:56:44.564Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="使用梯度下降算法进行学习"><a href="#使用梯度下降算法进行学习" class="headerlink" title="使用梯度下降算法进行学习"></a>使用梯度下降算法进行学习</h1><p>设计好神经网络的结构之后,它并不能进行任何任务,如mnist数据识别.<br>我们希望有一个算法,能让我们找到权重和偏置,以至于网络的输出y(x)能够拟合所有的训练输入x.<br>为了量化我们如何实现这个目标,我们定义一个<strong>代价函数</strong>:</p><p>这里w表示所有网络中权重的集合,b表示偏置项的集合.<br>为什么要引入这个代价函数呢?我们的目标原本是最大化正确分类的图像数量,但被正确分类的图像数量所关于权重和偏置的函数并不是一个平滑函数,所以引入一个类似二次代价的平滑代价函数更好的解决权重和偏置中微小改变带来的好处.</p><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;h1 id=&quot;使用梯度下降算法进行学习&quot;&gt;&lt;a href=&quot;#使用梯度下降算法进行学习&quot; class=&quot;headerlink&quot; title=&quot;使用梯度下降算法进行学习&quot;&gt;&lt;/a&gt;使用梯度下降算法进行学习&lt;/h1&gt;&lt;p&gt;设计好神经网络的结构之后,它并不能进行任何任务,如mnist数据识别.&lt;br&gt;我们希望有一个算法,能让我们找到权重和偏置,以至于网络的输出y(x)能够拟合所有的训练输入x.&lt;br&gt;为了量化我们如何实现这个目标,我们定义一个&lt;strong&gt;代价函数&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;这里w表示所有网络中权重的集合,b表示偏置项的集合.&lt;br&gt;为什么要引入这个代价函数呢?我们的目标原本是最大化正确分类的图像数量,但被正确分类的图像数量所关于权重和偏置的函数并不是一个平滑函数,所以引入一个类似二次代价的平滑代价函数更好的解决权重和偏置中微小改变带来的好处.&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习 神经网络 梯度下降" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/11/03/hello-world/"/>
    <id>http://yoursite.com/2018/11/03/hello-world/</id>
    <published>2018-11-03T06:43:54.480Z</published>
    <updated>2018-08-21T12:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr><ul><li>创建新文章</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n[ew] <span class="string">"postname"</span></span><br></pre></td></tr></table></figure><ul><li>修改后提交</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g[enerate]</span><br><span class="line">hexo d[eploy]</span><br></pre></td></tr></table></figure><ul><li>本地运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s[erver]</span><br></pre></td></tr></table></figure><p>添加右键点击桃心效果:</p><ol><li>复制<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="noopener">love.js</a></li><li>在<code>/themes/next/source/js/src</code>下新建love.js</li><li>将复制的内容粘贴至love.js</li><li>在<code>/themes/next/layout/_layout.swig</code>文件末尾加入js的引用代码 <code>http://7u2ss1.com1.z0.glb.clouddn.com/love.js</code></li><li>提交 <code>hexo g</code>, <code>hexo d</code> </li></ol><p>设置文件目录默认展开效果:</p><ol><li>编辑<code>themes/next/source/css/_custom/custom.styl</code></li><li>文章目录默认展开 加入<code>.post-toc .nav .nav-child { display: block; }</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python笔记</title>
    <link href="http://yoursite.com/2018/03/05/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/05/python笔记/</id>
    <published>2018-03-05T08:34:09.000Z</published>
    <updated>2018-03-05T09:24:17.000Z</updated>
    
    <content type="html"><![CDATA[<p># -<em>- coding: utf-8 -</em>-  魔法注释 防止中文注释报错</p><p>导包 先搜索当前路径 其次搜索PYTHONPATH环境变量 最后搜索默认路径  可在sys.path中查看<br>添加包路径: 1、直接修改sys.path.append(new_path);  2、设置环境变量PYTHONPATH<br>包下面必须有 __init__.py  否则只是普通文件夹</p><a id="more"></a><p>创建一个名为xxx的虚拟环境 不需要root权限<br>    $ virtualenv xxx<br>    $ cd xxx/<br>    $ source bin/activate<br>当不再使用虚拟环境中的库时，可以通过释放命令来退出环境<br>    $ deactivate</p><p>方向键乱码  easy_install readline</p><hr><p>xx:共有变量<br>_xx:单前置下划线 私有化属性方法 form model import *禁止导入 类对象和子类可以访问<br>__xx:双前置下划线 避免与子类中属性命名冲突 无法在类外部直接访问(名字重整)<br>__xx__:双前后下划线 用户名字空间的魔法对象或属性 如<strong>init</strong> 不用自己定义<br>xx_:单后置下划线 用于避免和python关键词冲突<br>类中的__func() 和 __member 不可被外部直接访问  但可以通过_className__func()或_className__member访问  此机制为 命名重整(name mangling)</p><p>isinstance(var, type); 判断var是不是 type类型  type可以使用tuple 意为或者</p><hr><pre><code>class className:    __slots__ = (&apos;att1&apos;, &apos;att2&apos;, ... , &apos;attn&apos;)</code></pre><p>仅允许给类添加 att1-attn这些实例   否则AttributeError异常<br>__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p><p>from model import *  会导入模块所以内容<br>在模块内指定 __all__ = [‘var1’,’var2’,…,’varn’]  则导入时 只导var1-varn  别的不导入</p><hr><p>动态给类添加函数</p><pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法...     self.age = age...&gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法&gt;&gt;&gt; s.set_age(25) # 调用实例方法</code></pre><hr><p>使用@property  可以将一个函数变成一个属性 使用.直接访问<br>使用@property时 @property本身会创建另一个@score.setter的装饰器 来完成赋值运算<br>要是没有实现这个函数  则属性为只读属性</p><pre><code>class Student(object):    @property    def score(self):        return self._score    @score.setter    def score(self, value):        if not isinstance(value, int):            raise ValueError(&apos;score must be an integer!&apos;)        if value &lt; 0 or value &gt; 100:            raise ValueError(&apos;score must between 0 ~ 100!&apos;)        self._score = value</code></pre><p>obj = property(getter, setter) 使用这个函数绑定两个函数 也可以实现效果 规定顺序 getter在前 obj可以和实际变量不同名</p><hr><p>className.__mro__ 包含了成员调用属性或方法的对象查找顺序<br>要是想指定调用可以使用 className().fun()<br>super().fun()  调用的函数 也是__mro__的第一个</p><p>type(var)  返回var的变量类型<br>dir()<br>eval() 函数可计算某个字符串，并执行其中的的 python 代码。<br>print(end=””) 默认换行  加上参数end=var 可在结束时打印end的内容而不是换行</p><p>类属性 实例属性<br>类方法 实例方法 静态方法</p><hr><p>格式符号    转换<br>%c            字符<br>%s            通过str() 字符串转换来格式化<br>%i            有符号十进制整数<br>%d            有符号十进制整数<br>%u            无符号十进制整数<br>%o            八进制整数<br>%x            十六进制整数（小写字母）<br>%X            十六进制整数（大写字母）<br>%e            索引符号（小写’e’）<br>%E            索引符号（大写“E”）<br>%f            浮点实数<br>%g            ％f和％e 的简写<br>%G            ％f和％E的简写</p><hr><p>列表  list = [var1, var2, var3, var4]<br>字典  dict = {key1:var1, key2:var2}<br>元组 tuple = (var1, var2, var3, var4)<br>集合   set = {var1, var2, var3, var4}<br>enumerate()可以遍历下标</p><pre><code>&gt;&gt;&gt; for i, var in enumerate(vars):...     print i, chr</code></pre><hr><p>列表list<br>mix = [‘小不点’, 3.14, [1,2,3]]  列表中可以存放任意类型的数据<br>len(list)  返回list的长度<br>list.append(var)  将var添加到列表尾<br>list.extend(list2)  将另一个list的元素添加进来<br>list.insert(pos, var)  将var添加到pos位置<br>可以直接通过索引访问list<br>list.remove(var)  将var移除list 移除不存在的值会报错<br>del list[pos]  将list[pos]移除<br>del list[st,ed]  将[st,ed)删除<br>del list  将整个列表删除 注:此时list已不在内存中  而不是空列表<br>list.pop()  移除并返回list的最后一个元素<br>list.pop(pos)  将索引值为pos的值移除并返回<br>list(st,ed)  将[st,ed)之间的元素返回<br>list之间的比较是从第一个元素开始比较大小，一旦出结果就返回，若两着元素不匹配(无法比较大小)会抛出错误<br>list1 = list1 + list2  将两个list拼接<br>list <em> n  list </em>= n   将list自身连接n次<br>var in list  var not in list   返回bool值  var是否在list中<br>  (对于列表里的列表不可查询) list=[1,[‘sj’]]  ‘sj’ in list 返回false  ‘sj’ in list[1] 返回true<br>dir(list)  列出list的函数<br>list.count(var)  统计var出现的次数<br>list.index(var)  查找var第一次出现的位置<br>list.index(var,st,ed)  查找var在[st,ed)中第一次出现的位置<br>list.reverse()  翻转list<br>list.sort()  排序 小到大 默认使用归并排序<br>list.sort(reverse=True)  排序大到小<br>list=list2[:] 深拷贝 只是a=[1,2,3] b=a[:]同级别深拷贝  如果a=[list1, list2] b=a[:] 则list1 list2还是浅拷贝<br>            import copy   b=copy.deepcopy(a)  递归深拷贝<br>            b=copy.copy(a)则相当于  b=a[:] 因为元组不可变 所以对元组此方法为浅拷贝<br>list=list2  浅拷贝<br>list = list.append(val)  会把list清空 append返回值为空</p><hr><p>字典dictionary<br>键唯一不可变  值不唯一可变  不可切片<br>dict[key] = val  添加<br>dict.update({otherDict})  将另一个dict的元素添加进来<br>del dict[key]  删除一组(key-val)<br>dict[key]  如果key不存在会出现异常<br>dict.get(key, default)  存在返回值，不存在返回默认值 默认为None<br>dict.keys() dict.values() dict.items()</p><hr><p>元组tuple<br>稳固版列表，内容不可修改，可被查看</p><p>函数可以返回多个值  底层是tuple</p><hr><p>集合set<br>无序 不重复 不可切片 不可索引<br>set.add(var)<br>set.discard(var)<br>x in set 判断set中是否有x</p><hr><p>string 为不可变对象 string的任何操作都不会影响原串 只将操作后的串当做返回值返回<br>strip() 去除前后空格<br>s.strip(rm)        删除s字符串中开头、结尾处，位于 rm删除序列的字符<br>s.lstrip(rm) s.rstrip(rm)      删除s字符串中开头|结尾处，位于 rm删除序列的字符<br>s.find(str, start=0, end=len(s)        查找指定字符串  找着返回下标 否则返回-1<br>s.rfind(str, start=0, end=len(s)    右边开始找<br>s.index(str, start=0, end=len(s)    作用同find() 找不着抛出异常<br>s.rindex(str, start=0, end=len(s)    右边开始找<br>s.count(str, start=0, end=len(s)    查找str出现的次数<br>s.replace(str1, str2, s.count(str1))将str1替换为str2 不超过count次<br>s.split(str=” “, 2) 以 str 为分隔符切片 s，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串<br>                    若以空白(“ “ \t \n等)为分隔符  则str参数直接不写即可<br>s.capitalize()        第一个单词的首字母大写<br>s.title()            所有单词的首字母大写<br>s.startswith(str) s.endswith(str)    判断是否以str开头|结束 返回值为bool<br>s.lower() s.upper()        大写-&gt;小写 | 小写-&gt;大写<br>s.ljust(n) s.rjust(n) s.center(n)  将字符串填充空格值长度为n 居左|右|中显示字符串<br>s.partition(str) | rpartition(str) 把s以str分割成三部分,s前，s和s后 | 右边开始找str<br>s.splitlines()    按照行分隔，返回一个包含各行作为元素的列表<br>s.isalpha s.isdigit s.isalnum    s只包含 字母|数字|字母数字<br>s.isspace()        如果 s 中只包含空格，则返回 True，否则返回 False.<br>s.join(str)        str为list 使用s连接str中每一个元素</p><hr><p>+= 操作调用 __iadd__方法，没有该方法时，再尝试调用__add__方法</p><ul><li>操作调用__add__方法<br>__iadd__方法直接在原对象a1上进行更新，该方法的返回值为None<br>__add__方法会返回一个新的对象，原对象不修改<br>因为对于不可变对象，根本没有 __iadd__方法，所以+=和+的效果是一样的，因为调的都是 __add__ 方法</li></ul><hr><p>文件相关操作:<br>f = open(‘filename’, ‘[r|w|a等]’)<br>f.read() f.read(n) f.readline() f.readlines() 全读|读n个字节|读一行|类似全读但返回行的列表<br>f.write()<br>f.seek(offset, from=(0|1|2)) 文件指针定位到0(头)|1(当前)|2(尾)的偏移offset(可正可负)个字节的位置 越界出异常<br>f.tell() 返回文件指针的当前位置<br>f.close()<br>import os<br>os.rename(“oldname”, “newname”) 重命名文件<br>os.remove(“filename”) 删除文件<br>os.mkdir(“dirname”) 创建文件夹<br>os.rmdir(“dirname”) 删除文件夹<br>os.getcwd() 获取当前路径==pwd<br>os.chdir(“path”) 跳转文件夹<br>os.listdir(“path”) ls path下的文件</p><hr><p>进程相关操作:<br>import os<br>os.fork() 效果同linux系统调用fork 两个返回值 0为子进程 父进程返回子进程id(windows无此函数)<br>os.getpid() 获取当前进程id<br>os.getppid() 获取父进程id</p><p>跨平台库 multiprocessing  主进程等子进程执行完<br>from multiprocessing import Process<br>p = Process(target=func, args=(var, var2, …, varn)) func为子进程要执行的函数 args为参数元组<br>p.start() 进程开始执行<br>p.join([timeout])  等待进程结束 或等待timeout秒</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;# -&lt;em&gt;- coding: utf-8 -&lt;/em&gt;-  魔法注释 防止中文注释报错&lt;/p&gt;
&lt;p&gt;导包 先搜索当前路径 其次搜索PYTHONPATH环境变量 最后搜索默认路径  可在sys.path中查看&lt;br&gt;添加包路径: 1、直接修改sys.path.append(new_path);  2、设置环境变量PYTHONPATH&lt;br&gt;包下面必须有 __init__.py  否则只是普通文件夹&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux笔记</title>
    <link href="http://yoursite.com/2018/03/05/linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/05/linux笔记/</id>
    <published>2018-03-05T08:32:57.000Z</published>
    <updated>2018-03-05T09:49:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>smtp服务配置 在/etc/main.rc下面</p><p>1 Standard commands(系统调用)用户在shell环境中可以操作的指令或可执行文件<br>2 System calls(系统调用)系统核心可呼叫的函数与工具等<br><a id="more"></a><br>3 Library functions(库函数)一些常用的函数与函数库 大部分为c的函数库<br>4 Special devices(设备文件说明)装置文件的说明 通常在/dev下的文件<br>5 File formats(文件格式)配置文件或者是某些文件的格式<br>6 Games and toys(游戏和娱乐)游戏<br>7 Miscellaneous(杂项惯例协定)惯例与协议等 例如linux文件系统 网络协议 ASCII code 等等的说明<br>8 Administrative Commands(管理员命令)系统管理员可用的管理指令<br>9 跟kernel有关的文件</p><p>C+u从光标处像前删除指令串 C+k从光标处向后删除指令串<br>C+a将光标移到指令串最开头 C+e讲光标移到指令串最后面<br>vim中使用:!command  command为shell命令  可在vim中执行shell命令</p><p>H:当前屏幕上方<br>M:当前屏幕中央<br>L:当前屏幕下方</p><p>ctrl+f–&gt;向上翻一页<br>ctrl+b–&gt;向下翻一页<br>ctrl+d–&gt;向下翻半页<br>ctrl+u–&gt;向上翻半页</p><p>20G:跳转到20行<br>G:跳转到最后一行<br>gg:跳转到第一行</p><p>w:向后跳一个单词的长度，即跳到下一个单词的首字母<br>b:向前跳一个单词的长度，即跳到上一个单词的首字母</p><p>D, d$:从当前光标开始剪切一直到行末<br>d0:从当前光标开始剪切一直到行首(包括行最前面的空格)<br>d^:从当前光标开始剪切一直到行首(不包括行最前面的空格)<br>x:删除当前光标处的字符  向后<br>X:删除当前光标前一个字符</p><p>选中一段代码<br>v: 从光标位置开始 到光标位置结束<br>V: 每次选一行<br>>>:向右移动<br>\&lt;\&lt;:向左移动<br>.:重复上次操作</p><p>rx:用字符x替换当前字符<br>R:替换光标已经后面的所有字符</p><p>:%s/old/new/g–&gt; 用new替代所有的old<br>:n1,n2s/old/new/g–&gt; 用new替代n1-n2行内所有的old</p><p>passwd 修改密码<br>useradd  添加用户<br>userdel -r username  彻底删除用户</p><p>date 显示日期<br>date    date +%[yY]/%m/%d%H%M%S </p><p>cal 显示日历<br>cal    cal 2016    cal 10 2016</p><p>bc 打开计算器  quit 离开计算器</p><p>touch 新建文件<br>:sp 分屏 :vsp 竖分屏 ctrl+w+w 在两个窗口切换<br>vertical resize +(-)n 当前分屏扩大(或减小)n个单位</p><p>grep xxx -rn ./ 递归查询当前目录下所有的xxx<br>-r 递归 -n显示行号 ./指当前目录</p><p>ctrl+s  锁屏  ctrl+q   解锁</p><p>:nohl  取消高亮<br>:set noai  取消自动缩进<br>:set paste 进入粘贴模式<br>:set nopaste 退出粘贴模式</p><p>tar zcvf filename.tar.gz filename2  打包压缩<br>tar zxvf filename.tar.gz        解压</p><p>df -sh    查看硬盘使用情况<br>du -sh  查看当前文件夹大小</p><p>umask  查看文件创建时默认权限<br>umask -S  以符号类型显示权限<br>umask 002  修改文件创建时的默认权限<br>(文件默认无x,目录默认有x,umask显示要去掉的权限,输入2表示要拿掉写权限)</p><p>chgrp groupname dirname/filename  修改文件/目录的用户组 -R 递归进行</p><p>chown username dirname/filename  修改文件/目录的所有者 -R 递归进行<br>chown username:groupname dirname/filename 同时修改用户组和所有者</p><p>chmod {ugoa} {+-=} {rwx} 文件或目录<br>u(user). g(group). o(other). a(all)<br>+(加入). -(除去). =(设置).<br>chmod u=rwx,go=rx file<br>chmod a+w file<br>chmod a-w file</p><p>chattr [+-=] [ASacdistu] 文件或目录 隐藏属性<br>+(增加) -(删除) =(设置)<br>A: 访问文件时不修改atime<br>S: 修改文件的时候同步写入磁盘<br>a: 文件只能追加数据不能删除和修改数据 (只有root有权限设置)<br>c: 存储时自动压缩文件 读取时自动解压<br>d: 当dump程序被执行时 设置d属性可使该文件或目录不被dump备份<br>i: 不能被 删除 改名 设置连接 写入 添加数据<br>s: 如果文件被删除它将完全从磁盘中删除<br>u: 与s相反 文件被删除数据还存在磁盘中 可以用来找回文件</p><p>chattr设置的是隐藏属性 需要以lsattr查看<br>lsattr [-adR] 文件或目录<br>-a: 将隐藏文件的属性也列出来<br>-d: 如果接的是目录 仅列出目录本身属性 而非目录内的文件名<br>-R: 连同子目录的数据一并显示</p><p>whereis -l    显示where搜索的目录    主要是/bin /sbin下的执行档 以及/usr/share/man底下的man page</p><p>find [PATH] [option] [action]<br>1.与时间相关的选项: 共有-atime, -ctime, -mtime.  以-mtime为例说明<br>-mtime  n: n为数字，第n天前的一天之内(n-&gt;n+1天内)被修改过的文件<br>-mtime +n: n天之前不含第n天(n+1天前)被修改过的文件<br>-mtime -n: n天之内含第n天(n天内)被修改过的文件<br>-newer file: file为一个存在的文件，列出比file还要新的文件<br>find / -mtime 0 (0表示当前时间,查找24小时内被修改过的文件)<br>find / -newer /home/sjq (查找文件日期比sjq新的文件)<br>2.与使用者有关的参数<br>-uid n: n为用户账号ID即UID<br>-gid n: n为用户组ID即GID<br>-user name: name为用户名称<br>-group name: name为组名<br>-nouser: 寻找owner不在/etc/passwd中的文件<br>-nogroup: 寻找group不在/etc/group中的文件   例如该用户或者用户组被删除了就会出现这两种情况<br>3.与文件权限及名称有关的参数<br>-name filename: 搜索名为filename的文件    find / -name “<em>sjq</em>“查询所有包含sjq的文件夹<br>-size [+-]SiZE: 搜索比SIZE还要大(+)或小(-)的文件  SIZE单位 c:byte k:1024bytes   例如50KB-&gt; 50k<br>-type TYPE: 搜索文件类型为type的文件<br>-perm mode: 搜索文件权限等于(=)mode的文件<br>-perm -mode: 搜索文件权限包含(&gt;=)mode的文件<br>-perm /mode: 搜索文件权限被mode(&lt;=)包含的所有文件<br>4.额外可进行的动作<br>-exec command: command为其它指令，-exec后面可以再接额外的指令来处理搜索到的结果<br>    find / -name “<em>sjq</em>“ -exec ls -l {} \;  将包含sjq的文件使用ls -l列出来  指令不支持别名  例如ll<br>        {} 代表的是由find找到的内容 -exec一直到 \;是关键词</p><p>找出/底下文件大小介于50k到60k之间的文件，并将权限完整的列出(ls -l)<br>find / -size +50k -a -size -60k -exec ls -l {} \;      (-a 是and的意思)<br>找出/下文件容量大于50k且文件所属人不是root的文件名,且将权限完整的列出(ls -l)<br>find / -size +50k -a ! -user root -exec ls -ld {} \;<br>find / -size +50k -a ! -user root -type f -exec ls -l {} \;        (两种都可以, !表示反向选择)<br>找出/下容量大于1500k已经容量等于0的文件<br>find / -size +1500k -o -size 0   (-o 是or的意思)</p><p>gzip file   删除原文件产生压缩文件<br>gzip -c file &gt; file.gz  (-c将压缩后的数据输出在屏幕上)<br>gzip -d file.gz   解压<br>gzip -v file   显示压缩比<br>gzip -# file   #为数字代表压缩等级 -1最快 压缩比最差  -9最慢 压缩比最好 默认-6<br>可以使用 zcat  zgrep  zmore  zless</p><p>bzip2 file  用法同gzip<br>bzip2 -k file   保留原文件并产生压缩文件<br>可以使用 bzcat  bzgrep  bzmore  bzless</p><p>xz, xzcat/xzmore/xzless/xzgrep</p><p>tar [-z|-j|-J] [cv] [-f 待建立的文件名] filename 打包压缩<br>tar [-z|-j|-J] [tv] [-f 既有的tar文件名]     查看文件名<br>tar [-z|-j|-J] [xv] [-f 既有的tar文件名] [-C 目录] 解压缩<br>-c建立打包文件 v查看打包文件名   -t查看打包文件名   -x解打包或解压缩可搭配-C在特定目录<br>-z 使用gzip后缀gz  -j 使用bzip2后缀bz  -J 使用xz后缀xz<br>-p: 保留备份数据的原本权限与属性<br>-P: 保留绝对路径<br>–exclude=FILE: 在压缩的过程中不将FILE打包</p><p>dd if=”input_file” of=”output_file” bs=”block_size” count=”number”<br>bs规划的一个block大小,默认512bytes(一个sector的大小)  count多少个bs的意思 </p><p>PS1(提示符限定)<br>\d: 可显示出[星期 月 日]的日期格式 如: “Mon Feb 2”<br>\H: 完整的主机名<br>\h: 仅取主机名在第一个小数点之前的名字<br>\t: 显示时间 为24小时格式[HH:MM:SS]<br>\T: 显示时间 为12小时格式[HH:MM:SS]<br>\A: 显示时间 为24小时格式[HH:MM]<br>\@: 显示时间 为12小时格式[am/pm]<br>\u: 目前使用者的账号名称<br>\v: BASH的版本信息<br>\w: 完整的工作目录名称 由根目录写起的目录名称 但家目录会以~代替<br>\W: 利用basename函数取得工作目录名称 仅显示最后一个目录名<br>#: 下达的第几个命令<br>\$: 提示字符 如果是root显示# 否则是$</p><p>bash通配符<br>* 代表0-无穷多个任意字符<br>? 代表一个任意字符<br>[] 代表一个括号内的字符    如[abcd] 表示abcd中的一个<br>[-] 代表编码顺序内的一个字符 如[0-9]表示0-9的一个<br>[^] 反选 如[^abc]表示非abc的任意一个</p><p>基础正则 /492</p><p>sed /504<br>-i直接修改源文件<br>a新增(下一行) c取代内容 d删除 i插入(上一行) p打印 s取代字符串替换</p><p>awk /511</p><p>ps 查看进程信息<br>-a 显示所有进程(包括其它用户)<br>-u 显示进程详细状态<br>-x 显示没有控制终端的进程<br>-w 显示加宽, 以便显示更多信息<br>-r 显示正在运行的进程</p><p>top 动态显示进程</p><p>shell<br>test /532<br>判断符号 [] /535</p><hr><pre><code>if ... then  &amp;&amp; ||    if [ exp ]; then        ...    elif [ exp2 ]; then        ...    else        ...    fi</code></pre><hr><pre><code>case ... esac    case $varname in        &quot;var1&quot;)            ...        ;;        &quot;var2&quot;)            ...        ;;        *)            ...        ;;    esac</code></pre><hr><pre><code>function    function fname() {        ....    }</code></pre><hr><pre><code>while do ... done    while [ condition ]    do        ...    done</code></pre><hr><pre><code>until do ... done    until [ condition ]    do        ...    done</code></pre><hr><pre><code>for ... do ... done    for var in con1 con2 con3 ...    do        ...    done    for (( 初始值; 限制值; 执行步阶 ))    do        ...    done</code></pre><hr><p>${}      用来做变量替换 与$没区别 但精确界定变量名范围<br>$()        在bin/shell中 与<code></code>(反引号)效果一样 做命令替换 并不是每种shell都支持<br>$(())    用来做整数运算<br>${RANDOM}  产生随机数<br>seq 1 n  产生1-n的顺序数</p><p>sh [-nvx] script.sh<br>-n:        不执行script 仅查询语法问题<br>-v:        执行前 先输出script<br>-x:        将用到的script输出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;smtp服务配置 在/etc/main.rc下面&lt;/p&gt;
&lt;p&gt;1 Standard commands(系统调用)用户在shell环境中可以操作的指令或可执行文件&lt;br&gt;2 System calls(系统调用)系统核心可呼叫的函数与工具等&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>win32笔记</title>
    <link href="http://yoursite.com/2018/03/05/win32%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/05/win32笔记/</id>
    <published>2018-03-05T08:31:22.000Z</published>
    <updated>2018-03-05T11:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>我应该知道：<br>1、WM_PAINT优先级很低， 基本总是处于消息队列尾部， 要实时重绘 可调用 UpdateWindow(hwnd);<br>2、windows很多结构第一个字段常被定义为sizeof(this); 目的是方便以后的版本可以扩充结构而保持与以前程序兼容<br>3、6种GDI对象<br><a id="more"></a><br>    CBitMap  - 位图是一种位矩阵，每一个显示像素都对应一个或多个位，我们可以用位图来表示图像，也可以用它来创建刷子。<br>    CBrush   - 刷子定义了一种位图形式的像素，用它可以对区域内部填充颜色。<br>    CFont    - 字体是一种具有某种风格和尺寸的所有字符的集合。<br>    CPalette - 调色板是一种颜色映射接口。<br>    Cpen     - 笔是一种画线和有形边框的工具，可以指定画线的宽度，以及画虚线，实线等。<br>    CRgn     - 区域是一种范围，可以用它来填充、裁剪以及鼠标点中测试。<br>4、3条规则控制GDI对象的使用<br>    最终应当删除创建的所有GDI对象<br>    当GDI对象被选入一个有效的设备环境时 不要删除它<br>    不要删除备用对象</p><p>#define WINAPI __stdcall<br>typedef unsigned short wchar_t;<br>strlen(char<em>) ASCII字符 wcslen(wchar_t</em>) 宽字符<br>TCHAR.h 头文件处理了 兼容ASCII和宽字符的函数集<br>TEXT()  宏可根据编码环境处理字符串为ASCII字符或宽字符<br>funA()-&gt;ascii版  funW()-&gt;宽字符版</p><p>打印信息: (在vcvs的空项目都能运行，vs的win32prj不可运行)<br>char szBuffer[100];<br>sprintf(szBuffer, “the value is %d”, val);<br>MessageBox(NULL, szBuffer, “msg”, MB_OK);<br>// win32prj中 第二个参数有问题 解决方案1:类型强转(LPCSTR)<br>int GetSystemMetrics(int nIndex) 获取windows的窗口大小<br>    nIndex = SM_CXSCREEN|SM_CYSCREEN (x轴像素点|压轴像素点)</p><hr><pre><code>typedef struct tagMSG {    HWND     hwnd;        消息所指向的窗口句柄    UINT    message;    消息标识符 大多数定义于WINUSER.H    WPARAM    wParam;        一个32位消息参数 意义和取值取决于具体消息    LPARAM    lParam;        同上    DWORD    time;        消息进入消息队列的时间    POINT    pt;            消息进入消息队列中时鼠标指针的位置坐标} MSG, *PMSG;typedef struct tagPOINT {    long x; long y;} POINT, *PPOINT;</code></pre><hr><p>GetMessage(&amp;msg, NULL, 0, 0);<br>函数像操作系统发送请求 获取要处理的消息 如果消息队列中检索到的消息的message字段不等于WM_QUIT(其值为0x0012),<br>则GetMessage将返回一个非0值，否则返回0</p><p>点击关闭按钮会产生一个WM_SYSCOMMAND消息 交由DefWindwoProc处理 发送一条WM_CLOSE消息 又交由DefWindwoProc处理<br>调用DestoryWindow(产生了WM_DESTORY消息?) 函数中调用PostQuitMessage 发送一条WM_QUIT消息 结束消息循环</p><p>消息既可以是”队列消息” 也可以是”非队列消息”  队列消息是指由windows放入程序的消息队列中的消息 在程序的消息循环中<br>消息被检索 然后被投递到窗口过程中   非队列消息则是由windows对窗口过程的直接调用而产生的<br>队列消息一般是”投递”(post)到消息队列中 而非队列消息则是被”发送”(send)到窗口过程<br>队列消息主要由用户的输入产生，主要形式为按键消息(例如 WM_KEYDOWN和WM_KEYUP) 由按键产生的字符消息(WM_CHAR)<br>鼠标移动(WM_MOUSEMOVE) 鼠标单击(WM_LBUTTONDOWN)<br>此外 队列消息还包括定时器消息(WM_TIMER) 重绘消息(WM_PAINT) 和退出消息(WM_QUIT)<br>非队列消息则包括队列消息以外的其它所有消息 非队列消息通常由调用特定的windows函数引起 例如 WinMain调用createWindow<br>会在创建窗口过程中向窗口过程发送一个WM_CREATE消息  而当WinMain调用showwindow时会发送WM_SIZE 和WM_SHOWWINDOW<br>updatewindow会发送 WM_PAINT<br>表明键盘或鼠标输入的队列消息也能产生非队列消息 例如 当键盘或鼠标选择某个菜单项时 键盘或鼠标消息会进入消息队列<br>而最终表明有某菜单项被选中的WM_COMMAND消息却是一个非队列消息<br>p86 关于消息处理的几段话没有看明白</p><p>WM_PAINT优先级很低， 基本总是处于消息队列尾部， 要实时重绘 可调用 UpdateWindow(hwnd);</p><p>#define LOWORD(l) ((WORD)(l))</p><p>#define HIWORD(l) ((WORD)(((WORD)(l)&gt;&gt;16)&amp;0xffff))</p><p>SetScrollRange(hwnd, iBar, iMin, iMax, bRedraw);  设置滚动条范围<br>iBar=[SB_VERT|SB_HORZ] iMin,iMax分别对应范围最小最大值 bRedraw是否重绘<br>如果在调用SetScrollRange函数之后还调用其它函数来调整滚动条的显示时 最好将bRedraw设置为FALSE以避免过多重绘<br>SetScrollPos(hwnd, iBar, iPos, bRedraw);  设置滑块位置<br>GetScrollRange() GetScrollPos() 获取滚动条的范围和当前位置<br>用户点击滚动条或滑块时会产生 WM_VSCROLL或WM_HSCROLL 消息 并伴随 鼠标按下 和 鼠标松开两条消息<br>WM_VSCROLL和WM_HSCROLL的lParam一般可忽略  它只用于滚动条是子窗口时 通常是在对话框中<br>wParam低字节代表了鼠标在滚动条上的操作 由一个以SB开头的标识符定义  wParam的高字节是用户拖动滑块的当前位置<br>如果在滚动条的不同部分按住鼠标不动，程序可能收到多条滚动条消息<br>当松开鼠标键时 程序会受到一条带有SB_ENDSCROLL通知码消息<br>将鼠标放在滑块上然后按下鼠标键时，可以移动滑块，会生成带SB_THUMBTRACK和SB_THUMBPOSITION通知码的消息<br>当wParam的低字节是SB_THUMBTRACK时，wParam的高字节是用户拖动滑块的当前位置，这个位置位于range内<br>当wParam的低字节是SB_THUMBPOSITION时 wParam的高字节是用户松开鼠标的最终位置 对于其他滚动条操作 wParam高字节应被忽略<br>很少同时处理这两个消息， 区别是前者实时更新界面 后者当滑块停止时更新界面<br>新引入的两个函数  SetScrollInfo GetScrollInfo 包含上述四个功能 还加入两个新功能 设定滑块大小 获得超过16位的滑块位置<br>wParam高字节存放的滑块位置只有16位 当数据超过65535后 无法表示 而GetScrollInfo可以处理<br>SetScrollInfo(hwnd, iBar, &amp;si, bRedraw);<br>GetScrollInfo(hwnd, iBar, &amp;si);<br>iBar=[SB_VERT|SB_HORZ|SB_CTL] CTL表示一个滚动条控件</p><hr><pre><code>si = typedef struct tagSCROLLINFO {    UINT cbSize;    // 设置为sizeof(SCROLLINFO)        UINT fMask;        // 要设置或获取的值    int nMin;        // 范围最小值        int nMax;        // 范围最大值    UINT nPage;        // 页面大小    int nPos;        // 当前位置    int nTrackPos;    // 当前追踪位置} SCROLLINFO, *PSCROLLINFO;</code></pre><hr><p>windows很多结构第一个字段常被定义为sizeof(this); 目的是方便以后的版本可以扩充结构而保持与以前程序兼容<br>fMask字段是一个或多个以SIF为前缀的标志</p><p>iValue = GetDevicesCaps(hdc, iIndex);<br>获取设备的信息 包括显示器的大小和它的色彩能力等<br>参数iIndex是定义在WINGDI.H中的29个标识符之一，标志返回的信息 </p><p>分辨率:每英寸像素点   像素尺寸:水平或垂直总像素点   度量尺寸:每英寸或毫米为单位的设备的客户区大小<br>像素尺寸 / 度量尺寸 = 分辨率;<br>5.2.4 设备的尺寸 133 全程懵逼</p><p>COLORREF(32位无符号长整型)来表示一种特定的颜色 0-7:R  8-15:G  16-23:B  24-31:0</p><p>#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))&lt;&lt;8))|(((DWORD)(BYTE)(b))&lt;&lt;16)))<br>GetRValue、GetGValue、GetBValue宏从COLORREF值中提取RGB颜色值</p><p>绘图函数<br>SetPixel(hdc, x, y, (COLORREF)crColor); 将坐标为(x,y)的像素点设定为某个特定的颜色<br>(COLORREF)crColor = GetPixel(hdc, x, y); 获取坐标为(x,y)的像素点的颜色值<br>MoveTo(hdc, x, y);(16位windows) 返回值是调用之前点坐标<br>MoveToEx(hdc, xBeg, yBeg, NULL); 最后一个参数指向一个POINT的指针 记录调用之前点位置<br>LineTo(hdc, xEnd, yEnd);<br>GetCurrentPositionEx(hdc, &amp;pt); 获取当前点坐标 pt是POINT对象<br>Polyline(hdc, apt, n); apt点数组 n数组长度  顺序连接apt中的点<br>Rectangle(hdc, xLeft, yTop, xRight, yBottom);  绘制矩形 不包含右边和下边界点<br>Ellipse(hdc, xLeft, yTop, xRight, yBottom);     绘制椭圆内切外面的矩形框<br>RoundRect(hdc, xLeft, yTop, xRight, yBottom, xCornerEllipse, yCornerEllipse);  绘制圆角矩形 后两个参数是在角落画椭圆<br>Arc   (hdc, xLeft, yTop, xRight, yBottom, xStart, yStart, xEnd, yEnd); 绘制椭圆从(xStart,yStart)-&gt;(xEnd,yEnd)的曲线<br>Chord (hdc, xLeft, yTop, xRight, yBottom, xStart, yStart, xEnd, yEnd); 在上一个基础上连接首尾直线的封闭曲线<br>Pie   (hdc, xLeft, yTop, xRight, yBottom, xStart, yStart, xEnd, yEnd); 在第一个基础上连接首-椭圆中心-尾的折线</p><p>画笔<br>HPen = GetStockObject(WHITE_PEN | BLACK_PEN | NULL_PEN); 可以获取备用画笔的句柄 白色 黑色 无画笔<br>HPen = SelectObject(hdc, hPen); 将画笔选入设备环境 返回前一个画笔的句柄<br>SelectObject(hdc, GetStockObject(WHITE_PEN)); 组合使用<br>创建画笔 CreatePen或者CretePenIndirect创建一个逻辑画笔 返回逻辑画笔的句柄<br>调用SelectObject将画笔传入设备环境中<br>释放设备环境之后 或者将其它画笔选入设备环境之后 需要调用DeleteObject释放画笔</p><p>创建画笔 CreatePen和CretePenIndirect不需要hdc<br>HPEN hpen = CreatePen(iPenStyle, iWidth, crColor);<br>iPenStyle决定画笔绘制的是实现还是虚线或者点线PS_SOLID|PS_DASH|PS_DOT|PS_DASHDOT|PS_DASHDOTDOT|PS_NULL|PS_INSIDEFRAME<br>对于PS_SOLID PS_NULL PS_INSIDEFRAME样式 参数iWidth表示画笔的宽度 当iWidth=0时 画笔宽度为1ps 备用画笔总是1ps宽<br>如果指定虚线或点线宽度大于1 windows会使用实心画笔来代替 (意思就是iWidth只能=1)<br>crColor是一个COLORREF值 指定画笔的颜色 对所有除PS_INSIDEFRAME之外的样式 windows自动将该颜色转换为能表示的最近的纯色<br>PS_INSIDEFRAME样式是唯一能够使用抖动色的画笔样式 并且只有当画笔宽度大于1时才如此<br>也可以通过建立一个类型为LOGPEN(逻辑画笔)的结构 并调用CreatePenIndirect函数来建立一个画笔<br>LOGPEN logpen; 这个结构有三个字段 (UINT)lopenStyle表示画笔样式 (POINT)lopnWidth以逻辑单位表示的画笔宽度<br>    还有(COLORREF)lopnColor表示画笔的颜色 windows仅使用lopnWidth中的x设置画笔宽度 y被忽略<br>hPen = CreatePenIndirect(&amp;logpen);</p><p>SelectObject(hdc, hPen);<br>DeleteObject(hpen);<br>hPen = SelectObject(hdc, CreatePen(PS_DASH, 0, RGB(255,0,0)));<br>DeleteObject(SelectObject(hdc, hPen));</p><p>GetObject(hPen, sizeof(LOGPEN), (LPVOID)&amp;logpen); 获取LOGPEN结构中各个字段成员的值<br>hPen = GetCurrentObject(hdc, OBJ_PEN); 获取当前被选入设备环境的画笔句柄</p><p>填充虚线和点线画笔间的空隙 由设备环境的背景模式和背景颜色共同决定<br>默认背景模式是OPAQUE(不透明) 空隙使用背景色(默认白色)填充<br>    可以使用SetBkColor(hdc, crColor);设置文字背景色 GetBkColor获取背景色<br>SetBkMode(hdc, TRANSPARENT(透明)); 设置背景模式透明 阻止windows填充背景色<br>GetBkMode(); 可以获取当前当前背景模式 要么是TRANSPARENT 要么是OPAQUE</p><p>在设备环境中绘制线条 其颜色由画笔和显示区域的颜色共同确定 对两个颜色使用ROP2(二元光栅操作)得出显示颜色<br>windows定义了16种ROP2运算码 默认设备环境中绘图模式是R2_COPYPEN 将画笔像素颜色复制到目标像素上<br>博客中叙述了16中运算模式<a href="http://blog.csdn.net/hopygreat/article/details/78950875" target="_blank" rel="noopener">http://blog.csdn.net/hopygreat/article/details/78950875</a><br>可以调用SetROP2(hdc, iDrawMode);  设置绘图模式<br>可以调用iDrawMode = GetROP2(hdc); 获取当前绘图模式 </p><p>画刷<br>Windows使用当前选入设备环境的画刷来填充图形，在默认情况下 使用的是备用对象WHITE_BRUSH(白色)<br>Windows定义了6种备用画刷：WHITE_BRUSH, LTGRAY_BRUSH, GRAY_BRUSH, DKGRAY_BRUSH,<br>        BLACK_BRUSH, NULL_BRUSH(又称为HOLLOW_BRUSH)<br>HBRUSH hBrush = GetStockObject(WHITE_BRUSH);可获取备用画刷<br>SelectObject(hdc, hBrush); 可以将画刷选入设备环境中<br>SelectObject(hdc, GetStockObject(NULL_PEN)); 可以绘制一个不含边框的图形<br>SelectObject(hdc, GetStockObject(NULL_BRUSH)); 可以绘制一个只含边框的图形<br>Polygon(hdc, apt, iCount); 绘制多边形 apt是POINT数组 iCount是点个数 如果最后一个点和第一个点不同 会自动连接一条线<br>PolyPolygon(hdc, apt, aiCounts, iPolyCount); 绘制多个多边形 apt是所有点数组<br>        aiCounts给出每个多边形顶点数 iPolyCount给出多边形个数<br>对Polygon, PolyPolygon windows都使用设备环境中的当前画刷来填充区域，至于内部是如何填充的 要取决于多边形填充模式<br>可以调用SetPolyFillMode(hdc, iMode)来设置填充模式<br>默认情况下 多边形填充模式是ALTERNATE(交替)，但是也可以将它设定为WINDING(螺旋) 较复杂 仅这两种选择 P164</p><p>创建画刷： windows允许使用5种函数来创建画刷 调用SelectObject将画笔传入设备环境中<br>hBrush = CreateSolidBrush(crColor);<br>hBrush = CreateHatchBrush(iHatchStyle, crColor); 创建阴影线标记画刷<br>    iHatchStyle = [HS_HORIZONTAL | HS_BDIAGONAL | HS_VERTICAL | HS_CROSS | HS_FDIAGONAL | HS_DIAGCROSS]<br>    此处存在填充线和背景色混合问题 背景模式 阴影线颜色 背景颜色<br>CreatePatternBrush() 和 CreateDIBPatternBrushPt() 创建位图画刷<br>hBrush = CreateBrushIndirect(&amp;logbrush); 包含上述四个功能 logbrush是LOGBRUSH结构的逻辑画刷对象<br>LOGPEN logbrush; 这个结构有三个字段 (UINT)lbStyle (COLORREF)lbColor (LONG)lbHatch</p><hr><pre><code>lbStyle字段的值决定着windows如何解释其他两个字段lbStyle            lbColor         lbHatchBS_SOLID           画刷的颜色      忽略BS_HOLLOW          忽略            忽略BS_HATCHED         阴影线的颜色    阴影线的样式BS_PATTERN         忽略            位图句柄BS_DIBPATTERNPT    忽略            指向DIB的指针</code></pre><hr><p>GDI映射模式mapping mode<br>与映射模式相关的有四个其他的设备环境属性 窗口原点 视口原点 窗口范围 视口范围<br>GDI函数中的坐标是逻辑坐标 windows要把其转换为设备单位 即像素</p><hr><pre><code>METRIC(公制) ENGLISH(英制) LO HI是低高精度    Twip杜撰词1/20点  1点=1/72英寸isotropic anisotropic是各向同性 各向异性映射模式        逻辑单位        x轴     y轴     值增加方向 MM_TEXT         像素            右      下      (默认)MM_LOMETRIC     0.1mm           右      上MM_HIMETRIC     0.01mm          右      上MM_LOENGLISH    0.01in.         右      上MM_HIENGLISH    0.001in.        右      上MM_TWIPS        1/1440in.       右      上MM_ISOTROPIC    自定义(x=y)     自定义  自定义MM_ANISOTROPIC  自定义(x!=y)    自定义  自定义</code></pre><hr><p>SetMapMode(hdc, iMapMode);    设置映射模式<br>iMapMode = GetMapMode(hdc);    获取映射模式</p><p>5.5.3 视图和窗口 172<br>ClientToScreen函数可以将客户区坐标转换为屏幕坐标 反之ScreenToClient<br>GetWindowRect函数以屏幕坐标的形式获取整个窗口的位置和大小<br>DPtoLP(hdc, pPoints, iNumber);    将设备点转换为逻辑点 pPoints是一个指向POINT数组的指针 iNumber是要转换的点个数<br>LPtoDP(hdc, pPoints, iNumber);  将逻辑点转换为设备点</p><p>win32消息机制常用消息<br>WM_CLOSE: 点右上角×,默认消息处理时会发送WM_DESTORY<br>WM_DESTORY: 窗口被销毁<br>WM_CREAT: 窗口被创建<br>WM_PAINT: 窗口重绘<br>WM_COMMAND: 点击按钮<br>WM_SIZE: 窗口大小改变 lParam的低字节 客户区cx 高字节 客户区cy<br>WM_LBUTTONDOWN: 鼠标左键点击 wparam低字节 鼠标x坐标 高字节y<br>WM_RBUTTONDOWN: 鼠标右键点击 wparam低字节 鼠标x坐标 高字节y<br>WM_MOUSEMOVE: 鼠标移动       wparam低字节 鼠标x坐标 高字节y</p><p>BOOL MoveWindow(HWND hWnd.int x.int y,int nWidth,int nHeight,BOOL BRePaint(窗口是否被重绘));<br>BOOL SetWindowText(HWND hwnd，LPCTSTR lpString);<br>int DialogBox(HINSTANCE hlnstance,LPCTSTRIpTemplate,HWND hWndParent,DLGPROC IpDialogFunc);<br>BOOL CALLBACK DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM IParam);<br>UINT GetDlgltemlnt(HWND hDlg,int nlDDlgltem,BOOL *IpTranslated,BOOL bSigned);<br>BOOL SetDlgltemlnt(HWND hDlg,int nLDDlgltem,UINT uValue,BOOL bSigned);<br>HWND GetDlgltem(HWND hDlg,int nlDDlgltem);<br>BOOL GetWindowRect(HWND hWnd，LPRECTlpRect);<br>BOOL GetCursorPos(LPPOlNT IpPoint);<br>string.format(“%s”, charArr);  将字符数值转换为字符串</p><p>DialogBox函数可显示rc文件里的对话框资源<br>函数原型：int DialogBox(HINSTANCE hlnstance,LPCTSTRIpTemplate,HWND hWndParent,DLGPROC IpDialogFunc);<br>返回值， 实例句柄， dlgID， 窗口句柄， 回调函数</p><p>DialogProc 对话框消息处理函数<br>BOOL CALLBACK DialogProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);<br>除了对MM_INITDIALOG消息的响应之外如果函数处理消息，则对话框应用程序应该返回非零值，否则返回0<br>对话框句柄， msg， wParam， lParam</p><p>获取对话框指定ID的文本转化为int<br>UINT GetDlgItemInt(HWND hDlg,int nlDDlgltem,BOOL *IpTranslated,BOOL bSigned);<br>值， 对话框句柄， ID， 函数调用是否成功返回值(一般设为null)， 是否是有符号数</p><p>将值设定到指定ID位置<br>BOOL SetDlgltemlnt(HWND hDlg,int nLDDlgltem,UINT uValue,BOOL bSigned）;<br>函数调用是否成功， 对话框句柄， ID， 写入值， 是否是有符号数</p><hr><pre><code>对话框退出代码switch(uMsg){    case WM_COMMAND:    {        if ( LOWORD(wParam) == IDCANCEL )        {            // 句柄+返回值            EndDialog( hwndDlg, IDCANCEL );            return true;        }    }}</code></pre><hr><p>当对话框还未显示出来的时候会产生一个WM_INITDIALOG消息</p><p>CListCtrl的InsertColumn可以在列表框中添加表头<br>// 获取列表框句柄<br>CListCtrl <em>pList = (CListCtrl</em>)GetDlgItem(IDC_LIST1);<br>// 插入 列号(0开始)，标题， 左对齐， 大小<br>pList-&gt;InsertColumn( 0, “学号”, LVCFMT_LEFT, 120 );<br>使用InsertColumn的前提是列表框的style-&gt;查看-&gt;报告</p><p>GetItemCount(); 获得列表框的行数<br>InsertItem( ID, str ); 将str插入到列表框的第一列<br>SetItemText( count, n, str ); 在列表框的第count行的第n+1列插入str</p><p>GetSelectionMark(); 获取虚线框选中项的行号<br>DeleteItem( nSel ); 删除列表框中的第nSel行</p><p>POSITION pos = pList-&gt;GetFirstSelectedItemPosition();<br>int nSel = pList-&gt;GetNextSelectedItem(pos);<br>基于蓝色框选中的位置</p><p>pList-&gt;GetSelectedCount(); 返回列表视图中被选择的项数<br>结合GetSelectionMark()</p><p>pList-&gt;SetExtendedStyle(LVS_EX_FULLROWSELECT); 设置一次选中一行</p><p>mfc核心头文件afxwin.h 核心方法virtual BOOL InitInstance(){}<br>需在有一个CWinApp的派生类  并有一个全局派生类对象</p><hr><pre><code>class CMyApp : public CWinApp{    virutal BOOL InitInstance()    {        statment;        return true/false;    }};CMyApp xxx;</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我应该知道：&lt;br&gt;1、WM_PAINT优先级很低， 基本总是处于消息队列尾部， 要实时重绘 可调用 UpdateWindow(hwnd);&lt;br&gt;2、windows很多结构第一个字段常被定义为sizeof(this); 目的是方便以后的版本可以扩充结构而保持与以前程序兼容&lt;br&gt;3、6种GDI对象&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MD笔记</title>
    <link href="http://yoursite.com/2018/02/01/MD%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/01/MD笔记/</id>
    <published>2018-02-01T12:57:35.000Z</published>
    <updated>2018-03-05T08:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是个h1标签"><a href="#这是个h1标签" class="headerlink" title="这是个h1标签"></a>这是个h1标签</h1><p>=====</p><h2 id="这是个h2标签"><a href="#这是个h2标签" class="headerlink" title="这是个h2标签"></a>这是个h2标签</h2><hr><h3 id="这是个h3标签"><a href="#这是个h3标签" class="headerlink" title="这是个h3标签"></a>这是个h3标签</h3><a id="more"></a><blockquote><p>听说这是区块应用<br>我就写着看看效果</p><blockquote><p>然后我写了两个看看效果</p><blockquote><p>接着又写了三个</p></blockquote></blockquote></blockquote><ul><li>这是列表1</li><li>这是列表1</li><li>这是列表1</li></ul><ul><li>这是列表2</li><li>这是列表2</li><li>这是列表2</li></ul><ul><li>这是列表3</li><li>这是列表3</li><li>这是列表3</li></ul><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li><p>听说乱序不影响效果</p><p> 这是个代码区块 一个tab就行<br> 或者四个空格</p></li></ol><hr><hr><hr><hr><hr><p>然后<a href="https://jqcc.github.io/" title="title属性" target="_blank" rel="noopener">这是一个</a>引用操作<br><a href="http://39.106.217.48/" title="我的博客" target="_blank" rel="noopener">我的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这是个h1标签&quot;&gt;&lt;a href=&quot;#这是个h1标签&quot; class=&quot;headerlink&quot; title=&quot;这是个h1标签&quot;&gt;&lt;/a&gt;这是个h1标签&lt;/h1&gt;&lt;p&gt;=====&lt;/p&gt;
&lt;h2 id=&quot;这是个h2标签&quot;&gt;&lt;a href=&quot;#这是个h2标签&quot; class=&quot;headerlink&quot; title=&quot;这是个h2标签&quot;&gt;&lt;/a&gt;这是个h2标签&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;这是个h3标签&quot;&gt;&lt;a href=&quot;#这是个h3标签&quot; class=&quot;headerlink&quot; title=&quot;这是个h3标签&quot;&gt;&lt;/a&gt;这是个h3标签&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
